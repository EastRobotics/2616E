#pragma config(Sensor, dgtl1,  autonCont,      sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define DRIVE_THRESHOLD_FORWARD 15 // Joystick forward threshold
#define DRIVE_THRESHOLD_TURN 15 // Joystick turn threshold
#define DRIVE_THRESHOLD_STRAFE 15 // Joystick strafe threshold
#define INITIAL_DRIVE_POWER 25 // The power that drive with logic will start it's linear function at for drive power
#define JOYSTICK_MOVEMENT_THRESHOLD 15 // The amount the joystick has to move for it to be used in the linear function to calculate RPM
#define GYROSCOPE_THRESHOLD 10 // Within how many tenths of a degree the gyroscope must be in to be considered correct
#define PID_SENSOR_INDEX    myEncoder

#define PID_MOTOR_INDEX     myMotor
#define PID_MOTOR_SCALE     -1

#define PID_DRIVE_MAX       80
#define PID_DRIVE_MIN     	20

#define PID_INTEGRAL_LIMIT  50

#define PID_STRAIGHT_THRESH 20


/////////////////////////////////////////////////////////////////////////////////////////
//
//                        Normal drive methods (No sensors)
//
/////////////////////////////////////////////////////////////////////////////////////////

// Cleaner way of setting all four drive motor speeds.
// Drive with checks to rule out errors with joystick controls
// PARAMETERS:
//	int: -127 to 127, speed for the front left motor
//	int: -127 to 127, speed for the back left motor
//	int: -127 to 127, speed for the front right motor
//	int: -127 to 127, speed for the back right motor
void driveRaw(int speedFL, int speedBL, int speedFR, int speedBR) {
	motor[driveFL] = speedFL; // Front left
	motor[driveBL] = speedBL; // Back left
	motor[driveFR] = speedFR; // Front right
	motor[driveBR] = speedBR; // Back right
}



// Set mecanum wheel motor speeds based on forward, turn, and strafe speeds
// PARAMETERS:
//	int: -127 to 127, speed to drive forward or backward respectively
//	int: -127 to 127, speed to turn left or right respectively
//	int: -127 to 127, speed to strafe left or right respectively
void drive(int speedForward, int speedTurn, int speedStrafe) {
	int speedFL = speedForward + speedTurn + speedStrafe;
	int speedBL = speedForward + speedTurn - speedStrafe;
	int speedFR = speedForward - speedTurn - speedStrafe;
	int speedBR = speedForward - speedTurn + speedStrafe;
	driveRaw(speedFL, speedBL, speedFR, speedBR);
}

void driveBackwards(int speedForward, int speedTurn, int speedStrafe) {
	int speedBR = speedForward + speedTurn + speedStrafe; // FL equivalent
	int speedFR = speedForward + speedTurn - speedStrafe; // BL equivalent
	int speedBL = speedForward - speedTurn - speedStrafe; // FR equivalent
	int speedFL = speedForward - speedTurn + speedStrafe; // BR equivalent
	driveRaw(speedFL, speedBL, speedFR, speedBR);
}

void driveTank(int speedRight, int speedLeft) {
	driveRaw(speedLeft,speedLeft,speedRight,speedRight);
}

// Drive with checks to rule out errors with joystick controls
// NOTE:
// 	Multipliers should always be (0 <= x <= 1.0). This avoids going too fast or slow and going out of proportion
// PARAMETERS:
//	int: -127 to 127, speed to drive forward or backward respectively
//	int: -127 to 127, speed to turn left or right respectively
//	int: -127 to 127, speed to strafe left or right respectively
//	float: What to reduce forward/backward speed to (0.7 -> 70% of input)
//	float: What to reduce left/right turn speed to (0.7 -> 70% of input)
//	float: What to reduce left/right strafe speed to (0.7 -> 70% of input)
void driveWithLogic(int speedForward, int speedTurn, int speedStrafe, bool reverse) {
	int multipliedSpeedForward = speedForward; // ((float) speedForward)*forwardMultiplier;
	int multipliedSpeedTurn = speedTurn; //((float) speedTurn)*turnMultiplier;
	int multipliedSpeedStrafe = speedStrafe; //((float) speedStrafe)*strafeMultiplier;

	byte forwardMult = (multipliedSpeedForward < 0) ? -1 : 1;
	byte turnMult = (multipliedSpeedTurn < 0) ? -1 : 1;
	byte strafeMult = (multipliedSpeedStrafe < 0) ? -1 : 1;

	multipliedSpeedForward = abs(multipliedSpeedForward);
	multipliedSpeedTurn = abs(multipliedSpeedTurn);
	multipliedSpeedStrafe = abs(multipliedSpeedStrafe);

	if (abs(multipliedSpeedForward) <= DRIVE_THRESHOLD_FORWARD) multipliedSpeedForward = 0;
	if (abs(multipliedSpeedTurn) <= DRIVE_THRESHOLD_TURN) multipliedSpeedTurn = 0;
	if (abs(multipliedSpeedStrafe) <= DRIVE_THRESHOLD_STRAFE) multipliedSpeedStrafe = 0;

	if(abs(multipliedSpeedForward) <= JOYSTICK_MOVEMENT_THRESHOLD) multipliedSpeedForward = 0;
	if(abs(multipliedSpeedTurn) <= JOYSTICK_MOVEMENT_THRESHOLD) multipliedSpeedTurn = 0;
	if(abs(multipliedSpeedStrafe) <= JOYSTICK_MOVEMENT_THRESHOLD) multipliedSpeedStrafe = 0;

	// TODO Cooler stuff than just thresholds :P
	// Consider it TODONE

	//uses linear interpolation or lerp to fix the logarithmic nature of a motor's RPM to motor speed ratio into linear growth
	multipliedSpeedForward = getLerpedSpeed(multipliedSpeedForward, INITIAL_DRIVE_POWER, DRIVE_THRESHOLD_FORWARD);
	multipliedSpeedTurn = getLerpedSpeed(multipliedSpeedTurn, INITIAL_DRIVE_POWER, DRIVE_THRESHOLD_TURN);
	multipliedSpeedStrafe = getLerpedSpeed(multipliedSpeedStrafe, INITIAL_DRIVE_POWER, DRIVE_THRESHOLD_STRAFE);

	if (abs(speedForward) <= JOYSTICK_MOVEMENT_THRESHOLD) multipliedSpeedForward = 0;
	if (abs(speedTurn) <= JOYSTICK_MOVEMENT_THRESHOLD) multipliedSpeedTurn = 0;
	if (abs(speedStrafe) <= JOYSTICK_MOVEMENT_THRESHOLD) multipliedSpeedStrafe = 0;

	multipliedSpeedForward *= forwardMult;
	multipliedSpeedTurn *= turnMult;
	multipliedSpeedStrafe *= strafeMult;
	//Double strafe speeds
	multipliedSpeedStrafe *= 2;
	multipliedSpeedStrafe = (multipliedSpeedStrafe > 127) ? 127 : multipliedSpeedStrafe;

	if (!reverse)
		drive(multipliedSpeedForward, multipliedSpeedTurn, multipliedSpeedStrafe); // Pass off the checked values to drive
	else
		driveBackwards(multipliedSpeedForward, multipliedSpeedTurn, multipliedSpeedStrafe); // Pass off the checked values to drive
}

// Drive with checks to rule out errors with joystick controls
// NOTE:
// 	Multipliers should always be (0 <= x <= 1.0). This avoids going too fast or slow and going out of proportion
// PARAMETERS:
//	int: -127 to 127, speed to drive forward or backward respectively
//	int: -127 to 127, speed to turn left or right respectively
//	int: -127 to 127, speed to strafe left or right respectively
//	float: What to reduce forward/backward speed to (0.7 -> 70% of input)
//	float: What to reduce left/right turn speed to (0.7 -> 70% of input)
//	float: What to reduce left/right strafe speed to (0.7 -> 70% of input)
void driveWithLogicTank(int speedRight, int speedLeft, bool reverse) {
	int multipliedSpeedRight = speedRight; // ((float) speedForward)*forwardMultiplier;
	int multipliedSpeedLeft = speedLeft; //((float) speedTurn)*turnMultiplier;

	byte rightMult = (multipliedSpeedRight < 0) ? -1 : 1;
	byte leftMult = (multipliedSpeedLeft < 0) ? -1 : 1;

	multipliedSpeedRight = abs(multipliedSpeedRight);
	multipliedSpeedLeft = abs(multipliedSpeedLeft);

	if (abs(multipliedSpeedRight) <= DRIVE_THRESHOLD_FORWARD) multipliedSpeedRight = 0;
	if (abs(multipliedSpeedLeft) <= DRIVE_THRESHOLD_TURN) multipliedSpeedLeft = 0;

	if(abs(multipliedSpeedRight) <= JOYSTICK_MOVEMENT_THRESHOLD) multipliedSpeedRight = 0;
	if(abs(multipliedSpeedLeft) <= JOYSTICK_MOVEMENT_THRESHOLD) multipliedSpeedLeft = 0;

	//uses linear interpolation or lerp to fix the logarithmic nature of a motor's RPM to motor speed ratio into linear growth
	multipliedSpeedRight = getLerpedSpeed(multipliedSpeedRight, INITIAL_DRIVE_POWER, DRIVE_THRESHOLD_FORWARD);
	multipliedSpeedLeft = getLerpedSpeed(multipliedSpeedLeft, INITIAL_DRIVE_POWER, DRIVE_THRESHOLD_TURN);

	if (abs(speedRight) <= JOYSTICK_MOVEMENT_THRESHOLD) multipliedSpeedRight = 0;
	if (abs(speedLeft) <= JOYSTICK_MOVEMENT_THRESHOLD) multipliedSpeedLeft = 0;

	multipliedSpeedRight *= rightMult;
	multipliedSpeedLeft *= leftMult;

	if (!reverse)
		driveTank(multipliedSpeedRight, multipliedSpeedLeft); // Pass off the checked values to drive
	else
		driveTank(multipliedSpeedRight * -1, multipliedSpeedLeft * -1); // Pass off the checked values to drive
}

// Set each side of the drive to a certain speed.
// PARAMETERS:
//  int: How fast to move the left side (-127 to 127)
//  int: How fast to move the right side (-127 to 127)
//void driveTank(int speedLeft, int speedRight){
//	if(abs(speedLeft) <= DRIVE_THRESHOLD_FORWARD) speedLeft = 0;
//	if(abs(speedRight) <= DRIVE_THRESHOLD_FORWARD) speedRight = 0;
//	driveRaw(speedLeft,speedLeft,speedRight,speedRight);
//}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                        Smart drive methods (Encoders & PID)
//
/////////////////////////////////////////////////////////////////////////////////////////

float RPMValues[10] = {0,0,0,0,0,0,0,0,0,0};
long lastTickCount[10] = {0,0,0,0,0,0,0,0,0,0};
//float RPMReadRate = 20.0;

// Sets the encoders on all of our drive motors back to 0.
void clearDriveEncoders() {
	nMotorEncoder[driveFR] = 0;
	nMotorEncoder[driveBR] = 0;
	nMotorEncoder[driveFL]= 0;
	nMotorEncoder[driveBL] = 0;
}

/* Variables used for encoder. Should probably be replaced with a struct
tMotor motorsToChange[5] = {driveFR,driveFR,driveBR,driveFL,driveBL}; //robotc glitch with value 0 we think
bool motorToMotorReverse[5] = {false,false, false, false, false};
int motorsToChangeSpeed[5] = {80,80,80,80,80};
long tickTarget[5];

// Clean way to set variables for storing tick values
// PARAMETERS:
//  tMotor: array of motors to use
//  long: ticks to move
// NOTE:
//  - You should enter the delta, the method will figure out the total
//  - For example, if you want it to go forward 300 and the encoder is already
//    at 1000, you should still only put in 300.
//  - Negative = backwards wheel movement.
void setupMotorTicks(tMotor *_motorsToChange, long ticks) {
motorsToChange = (tMotor) _motorsToChange;
for(int i = 1; i < 5; i++){
tickTarget[i] = (motorToMotorReverse[i]) ? ((ticks*-1)
+ nMotorEncoder[motorsToChange[i]]) : (ticks + nMotorEncoder[motorsToChange[i]]);
}
}

// Logic driving method to check against ticks. Base method for other encoder methods
// Reads encoder valte of the front motors for each side.
// PARAMETERS:
//  motor array: The motors to change
void driveTilEncoder(tMotor *_motorsToChange, int arrayLength) {
writeDebugStreamLine("------------------------------------");
writeDebugStreamLine("--       DRIVING TIL ENCODER      --");
writeDebugStreamLine("------------------------------------");
string debug = "";
writeDebugStreamLine("Driving til Encoder");
sprintf(debug,"FR: %i AR: %i",driveFR,motorsToChange[0]);
writeDebugStreamLine(debug);
motorsToChange = (tMotor) _motorsToChange;
bool continueRunning = true;
while (continueRunning) {
continueRunning = false;
for (int i=1; i<arrayLength; i++) {
tMotor _motor = motorsToChange[i];
// If we're not at the target yet
sprintf(debug, "at %i : goal: %i",nMotorEncoder[_motor],tickTarget[i]);
writeDebugStreamLine(debug);
if (motorToMotorReverse[i] ? nMotorEncoder[_motor] > tickTarget[i]
: nMotorEncoder[_motor] < tickTarget[i]) {
// Make sure we keep running and are at the right speed
continueRunning = true;
motor[_motor] = (motorToMotorReverse[i]) ? motorsToChangeSpeed[i]*-1 : motorsToChangeSpeed[i];
sprintf(debug,"set m %i to %i",i,motorsToChangeSpeed[i]);
writeDebugStreamLine(debug);
sprintf(debug,"mtmr: %d m:%i",motorToMotorReverse[i],_motor);
writeDebugStreamLine(debug);
sprintf(debug,"FR:%i,BR:%i,FL:%i,BL:%i",driveFR,driveBR,driveFL,driveBL);
writeDebugStreamLine(debug);
sprintf(debug,"FR:%i,BR:%i,FL:%i,BL:%i",motorsToChange[0],motorsToChange[1],motorsToChange[2],motorsToChange[3]);
writeDebugStreamLine(debug);
} else {
// Stop the motor
motor[_motor] = 0;
}
}
}
}

void setEncoderDriveSpeed(int speed) {
for(int i = 1; i < 5; i ++){
motorsToChangeSpeed[i] = speed;
}
}

// Point turn
void driveEncoderPointTurn(int ticks, bool right, int speed) {
setEncoderDriveSpeed(speed);
motorToMotorReverse[1] = right ? true : false;
motorToMotorReverse[2] = right ? true : false;
motorToMotorReverse[3] = right ? false : true;
motorToMotorReverse[4] = right ? false : true;
setupMotorTicks(motorsToChange, ticks);
driveTilEncoder(motorsToChange, 5);
}

// Straight
void driveEncoderNormal(int ticks, bool forward, int speed) {
setEncoderDriveSpeed(speed);
motorToMotorReverse[1] = forward ? false : true;
motorToMotorReverse[2] = forward ? false : true;
motorToMotorReverse[3] = forward ? false : true;
motorToMotorReverse[4] = forward ? false : true;
setupMotorTicks(motorsToChange, ticks);
driveTilEncoder(motorsToChange, 5);
}

// Strafe
void driveEncoderStrafe(int ticks, bool right, int speed) {
setEncoderDriveSpeed(speed);
motorToMotorReverse[1] = right ? true : false;
motorToMotorReverse[2] = right ? false : true;
motorToMotorReverse[3] = right ? false : true;
motorToMotorReverse[4] = right ? true : false;
setupMotorTicks(motorsToChange, ticks);
driveTilEncoder(motorsToChange, 5);
}
*/

/////////////////////////////////////////////////////////////////////////////////////////
//
//                        PID (Currently on the backburner)
//
/////////////////////////////////////////////////////////////////////////////////////////

tMotor motorsToChange[4] = {driveFL,driveFR,driveBR,driveBL};
bool motorToMotorReverse[4] = {false, false, false, false};
//long tickTarget[4];
//Setup the weights for the various stages of pid
float kP = 0.22; //Proportional Gain
float kI = 0.25; //Integral Gain
float kD = 0.00; //Derivitive Gain
float kL = 50.0; //Apparently this is there to be the integral limit, I think we missed it when working last time

bool pidRunning = false;
float pidRequestedValue = 0;
int pidMode = 0;
int pidSensor = -1; // -1 for encoders, port of the sensor to use a sensor
int pidSensorOffset = 0;  // amount to offset the sensor by (used for gyro turns)
float pidSensorScale = 1.0;
bool straightAssist = true;
int straightStartAngle = 0;

int pidCorrectSpeed(int input) {
	// limit drive
	if( abs(input) > PID_DRIVE_MAX )
		return (input > 0) ? PID_DRIVE_MAX : PID_DRIVE_MAX * -1;
	if( abs(input) < PID_DRIVE_MIN )
		return (input > 0) ? PID_DRIVE_MIN : PID_DRIVE_MIN * -1;
	return input;
}

task taskDrivePid() {
	pidRunning = true;

	if (straightAssist)
		straightStartAngle = SensorValue[gyroMain];

	float  pidSensorCurrentValue;
	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;
	float  pidDrive;

	clearDriveEncoders();

	// Init the variables - thanks Glenn :)
	pidLastError  = 0;
	pidIntegral   = 0;

	pidRequestedValue += ((pidSensor==-1) ? nMotorEncoder[driveBL] : 0); // Account for existing ticks

	while( true )
	{
		// Is PID control active ?
		if( true )
		{
			// Read the sensor value and scale
			pidSensorCurrentValue = ((pidSensor==-1) ? nMotorEncoder[driveBL] : SensorValue[pidSensor]) * pidSensorScale + pidSensorOffset;

			// calculate error
			pidError = pidSensorCurrentValue - pidRequestedValue;

			if (abs(pidError) < 7) {
				motor[ driveFL ] = 0;
				motor[ driveFR ] = 0;
				motor[ driveBL ] = 0;
				motor[ driveBR ] = 0;
				writeDebugStream("I finished brah");
				pidRunning = false;
				break;
			}
			// integral - if Ki is not 0
			if( kI != 0 )
			{
				// If we are inside controlable window then integrate the error
				if( abs(pidError) < PID_INTEGRAL_LIMIT )
					pidIntegral = pidIntegral + pidError;
				else
					pidIntegral = 0;
			}
			else
				pidIntegral = 0;

			// calculate the derivative
			pidDerivative = pidError - pidLastError;
			pidLastError  = pidError;

			// calculate drive
			pidDrive = (kP * pidError) + (kI * pidIntegral) + (kD * pidDerivative);
			pidDrive *= PID_MOTOR_SCALE;

			// limit drive
			pidDrive = pidCorrectSpeed(pidDrive);

			// debug stuff
			string debug = "";
			sprintf(debug,"PIDS: %i",pidDrive);
			writeDebugStreamLine(debug);
			debug = "";
			sprintf(debug,"Error: %i",pidError);
			writeDebugStreamLine(debug);
			debug = "";
			sprintf(debug,"Targ: %i",pidRequestedValue);
			writeDebugStreamLine(debug);

			// send to motor
			if (pidMode == 0) { // Normal drive
				// Save speeds to positive values
				int pidDriveLeft = abs(pidDrive);
				int pidDriveRight = abs(pidDrive);

				// Check if speeds need to be corrected
				if (straightAssist) {
					if (abs(straightStartAngle - SensorValue[gyroMain]) > PID_STRAIGHT_THRESH) { // If we need to correct
							if (straightStartAngle - SensorValue[gyroMain] > 0) { // If too far right (pos diff)
								// Slow the left motors
								pidDriveLeft -= 80;
							} else { // If too far left (neg diff)
								// Slow the right motors
								pidDriveRight -= 80;

						}
					}
				}

				// Correct signs on the speeds
				pidDriveLeft = (pidDrive > 0) ? pidDriveLeft : pidDriveLeft * -1;
				pidDriveRight = (pidDrive > 0) ? pidDriveRight : pidDriveRight * -1;

				// Make sure we didn't exceed bounds after changing
				pidDriveLeft = pidCorrectSpeed(pidDriveLeft);
				pidDriveRight = pidCorrectSpeed(pidDriveRight);

				// Set speeds
				motor[ driveFL ] = pidDriveLeft;
				motor[ driveBL ] = pidDriveLeft;
				motor[ driveFR ] = pidDriveRight;
				motor[ driveBR ] = pidDriveRight;
				} else if (pidMode == 1) { // Point turn
				motor[ driveFL ] = pidDrive;
				motor[ driveFR ] = pidDrive * -1;
				motor[ driveBL ] = pidDrive;
				motor[ driveBR ] = pidDrive * -1;
			}
		}
		else
		{
			// clear all
			pidError      = 0;
			pidLastError  = 0;
			pidIntegral   = 0;
			pidDerivative = 0;
			motor[ driveFL ] = 0;
		}

		wait1Msec( 20 );
	}

	motor[ driveFL ] = 0;
	motor[ driveFR ] = 0;
	motor[ driveBL ] = 0;
	motor[ driveBR ] = 0;
	pidRunning = false;
}

void pidDriveStraight(long ticksToMove) {
	pidRequestedValue = ticksToMove;
	pidMode = 0;
	pidSensor = -1;
	pidSensorOffset = 0;
	pidSensorScale = 1.00;
	kP = 0.077; //Proportional Gain
	kI = 0.0; //Integral Gain
	kD = 0.00; //Derivitive Gain
	kL = 50.0; //Integral Limit
	startTask(taskDrivePid);
}

void pidDrivePoint(long ticksToMove) {
	pidRequestedValue = ticksToMove;
	pidMode = 1;
	pidSensor = -1;
	pidSensorOffset = 0;
	pidSensorScale = 1.00;
	kP = 0.22; //Proportional Gain
	kI = 0.25; //Integral Gain
	kD = 0.00; //Derivitive Gain
	kL = 50.0; //Integral Limit
	startTask(taskDrivePid);
}

// breaks out if PID taking too long
void pidDriveStraightLimit(long ticksToMove, int termLimit) {
	pidDriveStraight(ticksToMove);
	int timeRunning = 0;
	while(pidRunning) {
		wait1Msec(10);
		timeRunning+=10;
		if(timeRunning > termLimit) {
			stopTask(taskDrivePid);
			pidRunning = false;
			driveRaw(0,0,0,0);
			break;
		}
	}
}

// breaks out if PID taking too long
void pidDrivePointLimit(long ticksToMove, int termLimit) {
	pidDrivePoint(ticksToMove);
	int timeRunning = 0;
	while(pidRunning) {
		wait1Msec(10);
		timeRunning+=10;
		if(timeRunning > termLimit) {
			stopTask(taskDrivePid);
			pidRunning = false;
			driveRaw(0,0,0,0);
			break;
		}
	}
}

void waitForPid() {
	while (pidRunning)
		wait1Msec(10);
}

void waitForPidLimit(int termLimit) {
	int timeRunning = 0;
	while(pidRunning) {
		wait1Msec(10);
		timeRunning+=10;
		if(timeRunning > termLimit) {
			stopTask(taskDrivePid);
			pidRunning = false;
			driveRaw(0,0,0,0);
			break;
		}
	}
}

void endPid() {
	stopTask(taskDrivePid);
}

// Michaels 3:30AM, day of competition, last minute gyro turn.
// Works, but might need some cleanup (and comments xD)
void turnToAngle(int degrees, int speed, bool stopMotors = true) {
	degrees = tempGyroFix(degrees);
	int currentGyroVal = tempGyroFix(SensorValue[gyroMain]);
	if (speed < 0) {
		if(degrees > currentGyroVal) {
			while(degrees > currentGyroVal) {
				driveRaw(speed, speed, speed*-1, speed*-1);
				wait1Msec(20);
				currentGyroVal = tempGyroFix(SensorValue[gyroMain]);
			}
			} else {
			int lastDegrees = currentGyroVal;
			while(lastDegrees <= currentGyroVal) {
				driveRaw(speed, speed, speed*-1, speed*-1);
				lastDegrees = currentGyroVal;
				wait1Msec(20);
				currentGyroVal = tempGyroFix(SensorValue[gyroMain]);
			}
			while(degrees > currentGyroVal) {
				driveRaw(speed, speed, speed*-1, speed*-1);
				wait1Msec(20);
				currentGyroVal = tempGyroFix(SensorValue[gyroMain]);
			}
		}
		driveRaw(25,25,-25,-25);
		wait1Msec(250);
		} else {
		if(degrees < currentGyroVal) {
			while(degrees < currentGyroVal) {
				driveRaw(speed,speed, speed*-1, speed*-1);
				wait1Msec(20);
				currentGyroVal = tempGyroFix(SensorValue[gyroMain]);
			}
			} else {
			int lastDegrees = currentGyroVal;
			while(lastDegrees >= currentGyroVal) {
				driveRaw(speed,speed, speed*-1, speed*-1);
				lastDegrees = currentGyroVal;
				wait1Msec(20);
				currentGyroVal = tempGyroFix(SensorValue[gyroMain]);
			}
			while(degrees < currentGyroVal) {
				driveRaw(speed,speed,speed*-1,speed*-1);
				wait1Msec(20);
				currentGyroVal = tempGyroFix(SensorValue[gyroMain]);
			}
		}
		driveRaw(-25,-25,25,25);
		wait1Msec(250);
	}
	if(stopMotors)
		driveRaw(0,0,0,0);
}

// Michael's 3:30 PM PID version of the turn to angle
// What a coincidence
void turnToAnglePID(int degrees, int initSpeed){
	degrees = tempGyroFix(degrees);
	int currentGyroVal = tempGyroFix(SensorValue[gyroMain]);
	pidSensor = gyroMain;
	pidMode = 1;
	pidSensorOffset = 0;
	pidSensorScale = 1.0;
	if(initSpeed < 0) {
		if(degrees < currentGyroVal) {
			pidSensorOffset = -3600;
		}
		} else {
		if(degrees > currentGyroVal) {
			pidSensorOffset = 3600;
		}
	}
	startTask(taskDrivePid);
	pidRequestedValue = degrees;
}

/*
// Drives the robot forward using PID to keep straight
// PARAMETERS:
//  long: How much to move forward (if positive) or backwards (if negative)
void driveStraightPID(long ticksToMove) {
bool _motorToMotorReverse[4] = {false, false, false, false};
motorToMotorReverse = _motorToMotorReverse;
tMotor _motorsToChange[4] = {driveFL,driveFR,driveBR,driveBL};
setupMotorTicks(_motorsToChange, ticksToMove);
startTask( drivePID );
}

// Does a point turn using PID to stay in place
// PARAMETERS:
//  long: How much to turn right (if positive) or left (if negative)
void drivePointTurnPID(long ticksToMove) {
bool _motorToMotorReverse[4] = {false, true, true, false};
motorToMotorReverse = _motorToMotorReverse;
tMotor _motorsToChange[4] = {driveFL,driveFR,driveBR,driveBL};
setupMotorTicks(_motorsToChange, ticksToMove);
startTask( drivePID );
}
*/

/*
task getRPMValues() {
while(true){
long tickCount[10] = {0,nMotorEncoder[driveFR],nMotorEncoder[driveBR],0,0,0,0,nMotorEncoder[driveFL],nMotorEncoder[driveBL],0};
for(int i = 0; i < 10; i++){
RPMValues[i] = (((((float)tickCount[i])-((float)lastTickCount[i]))*(60000.0/RPMReadRate))/627.2); // Made for torque geared motors
lastTickCount[i] = tickCount[i];
}
Logging RPM
// datalogDataGroupStart();
// datalogAddValue(0,RPMValues[1]);
// datalogAddValue(1,RPMValues[2]);
// datalogAddValue(2,RPMValues[7]);
// datalogAddValue(3,RPMValues[8]);
// datalogAddValue(4,50);
// datalogDataGroupEnd();

wait1Msec((int)RPMReadRate);
}
}
*/
