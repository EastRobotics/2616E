#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           testMotor,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float rpm = 0.0;
long lastTicks = nMotorEncoder[testMotor];
float RPMReadRate = 20.0;
float totalTrial = 0;
float trials = 200;

// Michael's code for rpm, not 100% what each number is for
task readRPM() {
	while(true) {
		long currentTicks = nMotorEncoder[testMotor];
		rpm = (((((float)currentTicks)-((float)lastTicks))*(60000.0/RPMReadRate))/627.2); // Made for torque geared motors
		lastTicks = currentTicks;
		wait1Msec(((int)round(RPMReadRate)));
	}
}

task main()
{
	startTask ( readRPM );

	// Data looks like following (Each row is 1 speed):
	// Motor setting | Trial count | Current speed | Average speed | Minimum speed | Maximum speed
	for (int i = 125; i >= -125; i-=5) { // For each speed
		motor[testMotor] = i;
		wait1Msec(1000); // Give it time to speed up
		float maximumSpeed = 0;
		float minimumSpeed = 0;
		long averageSpeed = 0;
		totalTrial += 1;
		for (int i1 = trials; i1 < trials; i1+=1) {
			if (rpm > maximumSpeed)
				maximumSpeed = rpm;
			if (rpm < minimumSpeed)
				minimumSpeed = rpm;
			averageSpeed += (long) (floor(rpm + 0.5)); // Round the float and add it to total, long cause it might get big
			datalogDataGroupStart();
			averageSpeed = averageSpeed/trials;
			datalogAddValue(1, i); // Motor speed
			datalogAddValue(2, i1); // Trial count
			datalogAddValue(3, totalTrial); // Total trial count
			datalogAddValue(4, rpm); // Current speed
			datalogAddValue(5, averageSpeed); // Average speed
			datalogAddValue(6, minimumSpeed); // Minimum speed
			datalogAddValue(7, maximumSpeed); // Max speed
			datalogDataGroupEnd();
			wait1Msec(25);
		}
	}
}
